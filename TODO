Roadmap march:

* implement timer using MVar technique from the belge tronbot
** strict-concurrency?
** repair resigning support
** cleanup

* mango chooses the most robust move

* implement zobrist hash of moves / board
** target 64bit word
** suitable as key to DataMap or the like
** quickcheck testing
** http://www.gnu.org/software/gnugo/gnugo_11.html#SEC139


* refactor Data.Tree.UCT
** factor out node evalution propagation
** factor out "negamax if done"
** "stateless" light uctnodes

* new state / board implementation
** ephemeral?
** updateGameState -> updateBoard becomes destructive
*** really test benchmark
*** must be completely isolated and self-contained
** can use runSTUArray or the like

* new glue between uctNew and gobanNew
** propagation of UCT values / rave values

* towards heuristic
** capture count / atari / atari evade
** patterns

* prior: even game more likely


General:
* ko / superko
** naive implementation done
* scoring
** territory done
* testing
** quickcheck
** hunit
* profile infrastructure
** http://www.haskell.org/haskellwiki/How_to_profile_a_Haskell_program
* benchmark
** criterion
* better board representation
** immutable array
** abstract implementation


Kurt.Move:
* better move generation logic ;)
** we are trying...
** initial primitive monte carlo player
** need to tune for speed!!!

Data.Goban:
* track ko state


Network.GoTextProtocol2.Server:
* merge commandargparserlist and commandHandlers lists
* implement a way so commandHandlers can be passed in from an inheriting module running startLoop


Network.GoTextProtocol2.Parser:
* handle #-prefix comments and empty lines
* handle preprocessing (as described on: http://www.lysator.liu.se/~gunnar/gtp/gtp2-spec-draft2/gtp2-spec.html)
