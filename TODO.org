#+STARTUP: showall hidestars

* Roadmap march:

* cheap heuristic
** cheap territory estimate - maybe bouzy?

* tune heuristic
** also include total liberty count

** analyze commands:

*** random playout variant


** config record
*** basically there via EngineState
** changeable via command line options
*** max uct iterations
*** max time spent
*** rave weight
*** uct exploratory constant
** changeable via gtp extension
*** kurt_configure is there, just add more options

---------------------------


* homework:
** command line options for various constants
*** UCT exploration
*** rave weight
*** heuristic / center heuristic
*** heuristic player
*** random player

* kgs support
** time management
*** time_settings
*** kgs-time_settings
*** kgs-game_over support

* nice to have

** wrap UCT in some toplevel object?

** sample playouts

** systematic testing of game logic like isSuicide


* tune updateGameState speed
** adjacentStuff is called very often
** policyRaveUCB1 could maybe do less computation


* refactoring
** GameState versus Goban and representation still could be improved

** STVectorGoban
*** toEnum / fromEnum would clearly be better than word(To/From)state

** if copyGoban is used cleverly, maybe runOneRandom could use runST without the RealWorld
*** it seems this would need something like STUArrays thaw / freeze support



** STUArray instead of STVector with thaw and freeze before and updateGameState



* implement zobrist hash of moves / board  / towards transposition tables
** target 64bit word
** suitable as key to DataMap or the like
** quickcheck testing
** http://www.gnu.org/software/gnugo/gnugo_11.html#SEC139




* towards heuristic
** prior: even game more likely
** patterns

* Data.Tree.UCT
** come back for "negamax if done"?


** possible incremental goban improvement: http://en.wikipedia.org/wiki/Disjoint-set_data_structure



General:
* ko / superko
** naive implementation done
* scoring
** area for now
* timer could be more sophisticated
* testing
** quickcheck
** hunit
* profile infrastructure
** http://www.haskell.org/haskellwiki/How_to_profile_a_Haskell_program
* benchmark
** criterion
* better board representation
** more high level stuff
*** incremential group and liberty tracking?



* Data.Goban.UArray
** http://stackoverflow.com/questions/976936/how-to-create-unboxed-mutable-array-instance/978143#978143
** http://www.mail-archive.com/haskell-cafe@haskell.org/msg38528.html
** http://www.mail-archive.com/haskell-cafe@haskell.org/msg38530.html
** http://www.mail-archive.com/haskell-cafe@haskell.org/msg38540.html

Network.GoTextProtocol2.Server:
* merge commandargparserlist and commandHandlers lists
* implement a way so commandHandlers can be passed in from an inheriting module running startLoop

Network.GoTextProtocol2.Parser:
* handle #-prefix comments and empty lines
* handle preprocessing (as described on: http://www.lysator.liu.se/~gunnar/gtp/gtp2-spec-draft2/gtp2-spec.html)
